// Generated by CoffeeScript 1.10.0
(function() {
  var DBConnect, EventEmitter, Schema, _, uuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  uuid = require('./uuid');

  EventEmitter = require('events').EventEmitter;

  Schema = require('./schema');

  DBConnect = (function(superClass) {
    extend(DBConnect, superClass);

    DBConnect.Schema = Schema;

    DBConnect.connTypes = {};

    DBConnect.uuid = uuid.v4;

    DBConnect.register = function(type, connector) {
      if (this.connTypes.hasOwnProperty(type)) {
        throw new Error("DBConnect.register_type_exists: " + type);
      }
      return this.connTypes[type] = connector;
    };

    DBConnect.hasType = function(type) {
      if (this.connTypes.hasOwnProperty(type)) {
        return this.connTypes[type];
      } else {
        return void 0;
      }
    };

    DBConnect.inners = {};

    DBConnect.has = function(name) {
      if (this.inners.hasOwnProperty(name)) {
        return this.inners[name];
      } else {
        return void 0;
      }
    };

    DBConnect.setup = function(args) {
      var i, len, module, ref, results1;
      if (this.inners.hasOwnProperty(args.name)) {
        throw new Error("DBConnect.setup_connection_exists: " + args.name);
      }
      if (!this.connTypes.hasOwnProperty(args.type)) {
        throw new Error("DBConnect.unknown_type: " + args.type);
      }
      this.inners[args.name] = args;
      args.loaders || (args.loaders = {});
      if (args.hasOwnProperty('module')) {
        if (args['module'] instanceof Array) {
          ref = args['module'];
          results1 = [];
          for (i = 0, len = ref.length; i < len; i++) {
            module = ref[i];
            results1.push(args.loaders[module] = require(module));
          }
          return results1;
        } else {
          return args.loaders[args.module] = require(args.module);
        }
      }
    };

    DBConnect.make = function(args) {
      var conn, type;
      if (!this.inners.hasOwnProperty(args)) {
        throw new Error("DBConnect.unknownSetup: " + args);
      } else {
        args = this.inners[args];
        type = this.connTypes[args.type];
        conn = new type(args);
        if (args.schema instanceof Schema) {
          conn.attachSchema(args.schema);
        }
        if (args.tableName instanceof Function) {
          conn.tableName = args.tableName;
        }
        return conn;
      }
    };

    DBConnect.defaultOptions = {};

    DBConnect.prototype.tableName = function(name) {
      return name;
    };

    function DBConnect(args) {
      var key, ref, val;
      this.args = _.extend({}, this.constructor.defaultOptions, args);
      this.modules = {};
      this.prepared = {};
      this.currentUser = null;
      ref = this.args.loaders;
      for (key in ref) {
        val = ref[key];
        this.loadModule(key, val);
      }
    }

    DBConnect.prototype.loadModule = function(key, loader) {
      var results1, val;
      if (this.modules.hasOwnProperty(key)) {
        console.error('conn.loadModule:duplicate_loader_key', key);
        throw {
          duplicate_loader_key: key
        };
      } else {
        this.modules[key] = loader;
        if (loader instanceof Function) {
          return loader(this);
        } else if (loader instanceof Object) {
          results1 = [];
          for (key in loader) {
            val = loader[key];
            if (loader.hasOwnProperty(key)) {
              loglet.debug('dbconnect.loadModule', key, val);
              if (val instanceof Function) {
                results1.push(this.prepare(key, val));
              } else {
                results1.push(this.prepareSpecial(key, val));
              }
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        } else {
          console.error('conn.loadModule:not_a_loader', key, loader);
        }
      }
    };

    DBConnect.prototype.attachSchema = function(schema) {
      if (!(schema instanceof Schema)) {
        throw new Error("attachSchema:not_a_schema " + schema);
      }
      this.schema = schema;
      return schema.conn = this;
    };

    DBConnect.prototype.connect = function(cb) {};

    DBConnect.prototype.query = function(stmt, args, cb) {
      if (this.prepared.hasOwnProperty(stmt)) {
        return this.prepared[stmt](this, args, cb);
      } else {
        return this._query.apply(this, arguments);
      }
    };

    DBConnect.prototype.queryOne = function(stmt, args, cb) {
      return this.query(stmt, args, (function(_this) {
        return function(err, res) {
          if (err) {
            return cb(err);
          } else if (!res || res.length === 0) {
            return cb({
              error: 'no_records_found'
            });
          } else {
            return cb(null, res[0]);
          }
        };
      })(this));
    };

    DBConnect.prototype.prepare = function(key, func) {
      if (this.prepared.hasOwnProperty(key)) {
        throw new Error(this.constructor.name + ".duplicate_prepare_stmt: " + key);
      }
      if (this.hasOwnProperty(key)) {
        throw new Error(this.constructor.name + ".duplicate_prepare_stmt: " + key);
      }
      if (func instanceof Function) {
        this.prepared[key] = func;
        return this[key] = func;
      } else {
        throw new Error(this.constructor.name + ".invalid_prepare_stmt_not_a_function: " + func);
      }
    };

    DBConnect.prototype.prepareSpecial = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.prepare.apply(this, args);
    };

    DBConnect.prototype.disconnect = function(cb) {};

    DBConnect.prototype.open = function(cb) {
      return this.connect(cb);
    };

    DBConnect.prototype.close = function(cb) {
      return this.disconnect(cb);
    };

    DBConnect.prototype.beginTrans = function(cb) {
      return cb(null, this);
    };

    DBConnect.prototype.commit = function(cb) {
      return cb(null, this);
    };

    DBConnect.prototype.rollback = function(cb) {
      return cb(null, this);
    };

    DBConnect.prototype.doneTrans = function(cb) {
      return (function(_this) {
        return function(err, res) {
          if (err) {
            return _this.rollback(function() {
              return cb(err);
            });
          } else {
            return _this.commit(function(err) {
              if (err) {
                return cb(err);
              } else {
                return cb(null, res);
              }
            });
          }
        };
      })(this);
    };

    DBConnect.prototype.insert = function(tableName, obj, cb) {
      var e, error, query, rec, res, table;
      try {
        if (!this.schema) {
          throw new Error("dbconnect.insert:schema_missing");
        }
        table = this.schema.hasTable(tableName);
        if (!table) {
          throw new Error("dbconnect:insert:unknown_table: " + tableName);
        }
        res = (function() {
          var i, len, results1;
          if (obj instanceof Array) {
            if (!this.supports('insertMulti')) {
              throw new Error(this.constructor.name + ".insert:multiple_records_not_supported");
            } else {
              results1 = [];
              for (i = 0, len = obj.length; i < len; i++) {
                rec = obj[i];
                results1.push(table.make(rec));
              }
              return results1;
            }
          } else {
            return table.make(obj);
          }
        }).call(this);
        query = this.generateInsert(table, res);
        return this.query(query, res, (function(_this) {
          return function(err, results) {
            if (err) {
              return cb(err);
            } else {
              loglet.debug(_this.constructor.name + ".insert:result", results instanceof Array);
              if (results instanceof Array) {
                return cb(null, _this.makeRecordSet(tableName, results));
              } else {
                return cb(null, _this.makeRecord(tableName, results));
              }
            }
          };
        })(this));
      } catch (error) {
        e = error;
        return cb(e);
      }
    };

    DBConnect.prototype["delete"] = function(tableName, args, cb) {
      var e, error, query, table;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        if (!this.schema) {
          return cb(new Error("dbconnect.delete:schema_missing"));
        }
        table = this.schema.hasTable(tableName);
        if (!table) {
          return cb(new Error("dbconnect:delete:unknown_table: " + tableName));
        }
        query = this.generateDelete(table, args);
        return this.query(query, {}, (function(_this) {
          return function(err) {
            if (err) {
              return cb(err);
            } else {
              return cb(null);
            }
          };
        })(this));
      } catch (error) {
        e = error;
        return cb(e);
      }
    };

    DBConnect.prototype.select = function(tableName, query, cb) {
      var e, error, table;
      if (arguments.length === 2) {
        cb = query;
        query = {};
      }
      try {
        if (!this.schema) {
          return cb(new Error("dbconnect.select:schema_missing"));
        }
        table = this.schema.hasTable(tableName);
        if (!table) {
          return cb(new Error("dbconnect:select:unknown_table: " + tableName));
        }
        query = this.generateSelect(table, query);
        return this.query(query, {}, (function(_this) {
          return function(err, results) {
            var error;
            try {
              if (err) {
                return cb(err);
              } else {
                loglet.debug(_this.constructor.name + ".select", tableName);
                return cb(null, _this.makeRecordSet(tableName, results));
              }
            } catch (error) {
              err = error;
              return cb(err);
            }
          };
        })(this));
      } catch (error) {
        e = error;
        return cb(e);
      }
    };

    DBConnect.prototype.selectOne = function(tableName, query, cb) {
      return this.select(tableName, query, (function(_this) {
        return function(err, recordset) {
          if (err) {
            return cb(err);
          } else {
            if (recordset.length > 0) {
              return cb(null, recordset.first());
            } else {
              return cb(new Error("dbconnect.selectOne:no_record_returned: " + tableName + ", " + (JSON.stringify(query))));
            }
          }
        };
      })(this));
    };

    DBConnect.prototype.uuid = uuid.v4;

    DBConnect.prototype.normalizeRecord = function(table, rec) {
      return rec;
    };

    DBConnect.prototype.makeRecord = function(tableName, rec) {
      return this.schema.makeRecord(this, tableName, rec);
    };

    DBConnect.prototype.makeRecordSet = function(tableName, recs) {
      return this.schema.makeRecordSet(this, tableName, recs);
    };

    DBConnect.prototype.supports = function(key) {
      return false;
    };

    DBConnect.prototype.generateInQuery = function() {
      throw new Error("DBConnect.generateInQuery:not_supported");
    };

    DBConnect.prototype.generateSchema = function(schema) {
      if (schema == null) {
        schema = this.schema;
      }
    };

    return DBConnect;

  })(EventEmitter);

  module.exports = DBConnect;

}).call(this);
