// Generated by CoffeeScript 1.10.0
(function() {
  var Driver, EventEmitter, NoPool, Pool, Promise, _, loglet,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Driver = require('./driver');

  EventEmitter = require('events').EventEmitter;

  _ = require('lodash');

  loglet = require('loglet');

  Promise = require('bluebird');

  NoPool = (function() {
    function NoPool(key, type, driver, connOptions, options1) {
      var noPoolDriver, self;
      this.key = key;
      this.type = type;
      this.connOptions = connOptions;
      this.options = options1;
      self = this;
      this.driver = noPoolDriver = (function(superClass) {
        extend(noPoolDriver, superClass);

        function noPoolDriver() {
          return noPoolDriver.__super__.constructor.apply(this, arguments);
        }

        noPoolDriver.id = 0;

        return noPoolDriver;

      })(driver);
    }

    NoPool.prototype.connect = function(cb) {
      var conn;
      conn = new this.driver(this.key, this.connOptions);
      return conn.connect(cb);
    };

    NoPool.prototype.prepare = function(call, options) {
      var proc;
      proc = (function() {
        if (options != null ? options.query : void 0) {
          return function(args, cb) {
            return this.query(options.query, args, cb);
          };
        } else if (options != null ? options.exec : void 0) {
          return function(args, cb) {
            return this.exec(options.exec, args, cb);
          };
        } else if (options instanceof Function) {
          return options;
        } else {
          throw {
            error: 'invalid_prepare_option',
            call: call,
            options: options
          };
        }
      })();
      this.driver.prototype[call] = proc;
      return Promise.promisifyAll(this.driver.prototype);
    };

    return NoPool;

  })();

  NoPool.prototype.connectAsync = Promise.promisify(NoPool.prototype.connect);

  Pool = (function(superClass) {
    extend(Pool, superClass);

    Pool.NoPool = NoPool;

    Pool.defaultOptions = {
      min: 0,
      max: 20
    };

    function Pool(key, type, driver, connOptions, options1) {
      var poolDriver, self;
      this.key = key;
      this.type = type;
      this.connOptions = connOptions;
      this.options = options1;
      this.options = _.extend({}, this.constructor.defaultOptions, this.options || {});
      self = this;
      this.driver = poolDriver = (function(superClass1) {
        extend(poolDriver, superClass1);

        function poolDriver() {
          return poolDriver.__super__.constructor.apply(this, arguments);
        }

        poolDriver.id = 0;

        poolDriver.prototype.disconnect = function(cb) {
          return self.makeAvailable(this);
        };

        return poolDriver;

      })(driver);
      this.total = [];
      this.avail = [];
    }

    Pool.prototype.connect = function(cb) {
      var connectMe, db;
      connectMe = function(db) {
        if (db.isConnected()) {
          return cb(null, db);
        } else {
          return db.connect(cb);
        }
      };
      if (this.avail.length > 0) {
        db = this.avail.shift();
        return connectMe(db);
      } else {
        this.once('available', connectMe);
        if (this.total.length < this.options.max) {
          db = new this.driver(this.key, this.connOptions);
          this.total.push(db);
          return this.makeAvailable(db);
        }
      }
    };

    Pool.prototype.prepare = function(call, options) {
      var proc;
      proc = (function() {
        if (options != null ? options.query : void 0) {
          return function(args, cb) {
            return this.query(options.query, args, cb);
          };
        } else if (options != null ? options.exec : void 0) {
          return function(args, cb) {
            return this.exec(options.exec, args, cb);
          };
        } else if ((options instanceof Function) || (typeof options === 'function')) {
          return options;
        } else {
          throw {
            error: 'invalid_prepare_option',
            call: call,
            options: options
          };
        }
      })();
      this.driver.prototype[call] = proc;
      return Promise.promisifyAll(this.driver.prototype);
    };

    Pool.prototype.makeAvailable = function(db) {
      if (!_.contains(this.avail, db)) {
        this.avail.push(db);
      }
      return this.emit('available', db);
    };

    return Pool;

  })(EventEmitter);

  Pool.prototype.connectAsync = Promise.promisify(Pool.prototype.connect);

  module.exports = Pool;

}).call(this);
