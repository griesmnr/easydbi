// Generated by CoffeeScript 1.4.0

/*
dbi = require 'dbi'
dbi.register require 'dbi-pg'

# are we going to try to use promise? 
conn = dbi.connect('sqlite3', options, db)
*/


(function() {
  var DBI, Driver,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Driver = require('./driver');

  DBI = (function() {

    function DBI() {}

    DBI.drivers = {};

    DBI.register = function(key, driver) {
      this.drivers[key] = driver;
      return this;
    };

    DBI.clone = function(key, newKey) {
      var DriverWrapper, driver;
      driver = this.get(key);
      this.register(newKey, DriverWrapper = (function(_super) {

        __extends(DriverWrapper, _super);

        function DriverWrapper() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          this.inner = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(driver, args, function(){});
        }

        DriverWrapper.prototype.connect = function() {
          var args, cb, self, _i, _ref;
          args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
          self = this;
          return (_ref = this.inner).connect.apply(_ref, __slice.call(args).concat([function(err, inner) {
            if (err) {
              return cb(err);
            } else {
              return cb(null, self);
            }
          }]));
        };

        DriverWrapper.prototype.query = function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = this.inner).query.apply(_ref, args);
        };

        DriverWrapper.prototype.queryOne = function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = this.inner).queryOne.apply(_ref, args);
        };

        DriverWrapper.prototype.exec = function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = this.inner).exec.apply(_ref, args);
        };

        DriverWrapper.prototype.disconnect = function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = this.inner).disconnect.apply(_ref, args);
        };

        return DriverWrapper;

      })(Driver));
      return this;
    };

    DBI.get = function(key) {
      if (this.drivers.hasOwnProperty(key)) {
        return this.drivers[key];
      } else {
        throw {
          error: 'unknown_dbi_driver',
          key: key
        };
      }
    };

    DBI.make = function(key, options) {
      var driver;
      driver = this.get(key);
      return new driver(options);
    };

    DBI.load = function(key, module) {
      var call, options, _results;
      _results = [];
      for (call in module) {
        options = module[call];
        _results.push(this.prepare(key, call, options));
      }
      return _results;
    };

    DBI.prepare = function(key, call, options) {
      var driver;
      driver = this.get(key);
      driver.prototype[call] = this._prepare(driver, call, options);
      return this;
    };

    DBI._prepare = function(driver, call, options) {
      if (options != null ? options.query : void 0) {
        return function(args, cb) {
          return this.query(options.query, args, cb);
        };
      } else if (options != null ? options.exec : void 0) {
        return function(args, cb) {
          return this.exec(options.exec, args, cb);
        };
      } else if (options instanceof Function) {
        return options;
      } else {
        throw {
          error: 'invalid_prepare_option',
          call: call,
          options: options
        };
      }
    };

    return DBI;

  })();

  module.exports = DBI;

}).call(this);
